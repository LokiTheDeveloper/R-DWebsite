/**
 * @OnlyCurrentDoc
 * This script creates a custom menu to automate invoice and receipt processing,
 * and to send follow-up emails based on data in the spreadsheet.
 */

// --- CONFIGURATION CONSTANTS ---
const CONFIG = {
  SHEET_NAMES: {
    INVOICE_ENCODER: 'RDRInvoiceReceiptEncoder',
    AR_ENCODER: 'AREncoder',
    DATABASE: 'EntryDatabase',
    SALES_DB: 'SalesDatabase',
  },
  NAMED_RANGES: {
    INVOICE_PDF: 'InvoicePdfRange',
    INVOICE_DATA: 'InvoiceDataRange',
    INVOICE_CLEAR: 'InvoiceClearRange',
    AR_PDF: 'ArPdfRange',
    AR_DATA: 'ArDataRange',
  },
  // We can add the other business info here for even better organization
  COMPANY_NAME: 'RDR Business Solutions, Inc.',
  COLLECTIONS_OFFICER_NAME: 'Ma. Sophia P. Martinez',
  COLLECTIONS_OFFICER_TITLE: 'Collection Officer',
  FINANCE_EMAIL: 'finance@rdrcorporation.com',
  FINANCE_PHONE: '0945 559 6470',
  PAYMENT_LINK: 'https://YOUR_PAYMENT_LINK_HERE',
  CUTOFF_HOUR_24: 17, // 5 PM
  CUTOFF_MINUTE:  0,
};

// Cutoff for "Due Today" final reminder (local script timezone)
const CUTOFF_HOUR_24 = 17; // 5 PM
const CUTOFF_MINUTE  = 0;

// --- HELPERS ---

// [PASTE THIS ENTIRE BLOCK into your HELPERS section]

/**
 * Extracts and maps data from the Invoice Encoder form values.
 * @param {any[][]} values - The 2D array of values from the InvoiceDataRange.
 * @returns {object} An object containing all the named data points.
 */
function extractInvoiceData_(values) {
  const IDX = {
    date: 0, tin: 1, fullName: 2, business: 3, address: 4, city: 5, zip: 6,
    campaign: 7, amount: 8, dpDue: 9, fpDue: 10, email: 11, serial: 12, timeSent: 13
  };
  
  const data = {};
  data.entryDate = values[IDX.date][0];
  data.tin = values[IDX.tin][0];
  data.clientName = values[IDX.fullName][0];
  data.business = values[IDX.business][0];
  data.address = values[IDX.address][0];
  data.city = values[IDX.city][0];
  data.zip = values[IDX.zip][0];
  data.campaign = values[IDX.campaign][0];
  data.amountRaw = values[IDX.amount][0];
  data.dpDueDate = values[IDX.dpDue][0];
  data.fpDueDate = values[IDX.fpDue][0];
  data.clientEmail = values[IDX.email][0];
  data.serialNo = values[IDX.serial][0];
  data.timeSent = new Date();
  data.amountNum = (typeof data.amountRaw === 'number') ? data.amountRaw : parseFloat(String(data.amountRaw).replace(/[^\d.-]/g, '')) || 0;
  
  return data;
}

/**
 * Extracts and maps data from the AR Encoder form values.
 * @param {any[][]} values - The 2D array of values from the ArDataRange.
 * @returns {object} An object containing all the named data points.
 */
function extractArData_(values) {
  const displayValues = SpreadsheetApp.getActive().getRangeByName(CONFIG.NAMED_RANGES.AR_DATA).getDisplayValues();
  const IDX = { date: 0, amount: 4, mode: 5, serial: 6, arNum: 7, name: 8, email: 10 };

  const data = {};
  data.dateReceived = values[IDX.date][0];
  data.amountRaw = values[IDX.amount][0];
  data.modeOfPayment = values[IDX.mode][0];
  data.serialInvoiceNo = String(values[IDX.serial][0] || '').trim();
  data.arNumber = String(values[IDX.arNum][0] || '').trim();
  data.clientNameRaw = displayValues[IDX.name][0];
  data.clientEmail = String(values[IDX.email][0] || '').trim();

  return data;
}

function addDays_(d, n) {
  const x = new Date(d);
  x.setDate(x.getDate() + n);
  return x;
}

function fmtDate_(d) {
  if (!(d instanceof Date)) return '';
  return Utilities.formatDate(d, Session.getScriptTimeZone(), 'MMMM d, yyyy');
}

function toTitleCase_(s) {
  if (!s) return "";
  return String(s)
    .split(/[\s._-]+/)
    .map(w => w ? (w[0].toUpperCase() + w.slice(1).toLowerCase()) : "")
    .join(" ");
}

function toPhp_(val) {
  const n = (typeof val === 'number') ? val : parseFloat(String(val).replace(/[^\d.-]/g,"")) || 0;
  return n.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' });
}

function dateOnly_(val) {
  if (!val || !(val instanceof Date)) return null;
  const d = new Date(val);
  d.setHours(0, 0, 0, 0);
  return d;
}

function firstNameFromEmail_(email) {
  if (!email) return "Client";
  const local = String(email).split("@")[0] || "";
  const guess = local.split(/[.-_]+/)[0] || "Client";
  return toTitleCase_(guess);
}

function safeGetUi_() {
  try {
    return SpreadsheetApp.getUi();
  } catch (_) {
    return null; // no UI in this context
  }
}

/**
 * Build official Down Payment email (subject + html) per spec.
 * Inputs:
 *  - fullName, business, campaign, meetingDate(Date), givenAmount(number),
 *    invoiceSerial, paymentLink, financeEmail, financePhone, officerName, officerTitle, companyName
 */
// [PASTE THIS ENTIRE BLOCK to replace the broken section]

// [PASTE THIS ENTIRE BLOCK to replace the broken section]

function buildDownpaymentEmail_({
  fullName, business, campaign, meetingDate, givenAmount, invoiceSerial,
  paymentLink = CONFIG.PAYMENT_LINK,
  financeEmail = CONFIG.FINANCE_EMAIL,
  financePhone = CONFIG.FINANCE_PHONE,
  officerName = CONFIG.COLLECTIONS_OFFICER_NAME,
  officerTitle = CONFIG.COLLECTIONS_OFFICER_TITLE,
  companyName = CONFIG.COMPANY_NAME
}) {
  const clientNameSafe = fullName && String(fullName).trim() ? String(fullName).trim() : (business && String(business).trim()) ? String(business).trim() : 'Client';
  const meetStr = fmtDate_(meetingDate);
  const due3Str = fmtDate_(addDays_(meetingDate, 3));
  const contractPrice = toPhp_(givenAmount);
  const dp30 = toPhp_(Number(givenAmount) * 0.30);
  const subject = `Down Payment Requirement â€“ Minimum 30% [Billing Invoice #${invoiceSerial}] â€“ Payable Within 3 Days`;
  const buttonHtml = `<a href="${paymentLink}" style="background-color:#007bff;color:#fff;padding:10px 16px;text-decoration:none;border-radius:6px;display:inline-block;">View Payment Options</a>`;
  const body = `
  <p>Hi <b>${toTitleCase_(clientNameSafe)}</b>,</p>
  <p>It was a pleasure meeting with you regarding your <b>${campaign || 'engagement'}</b> with <b>${companyName}</b>.</p>
  <p>As discussed and in accordance with our agreement, a down payment of at least <b>30%</b> of the total contract price is required to secure your booking and allow us to begin preparations.</p>
  <p>You are given three (3) calendar days from today, <b>${meetStr}</b>, to settle the required down payment.</p>
  <p><b>Contract Price:</b> <b>${contractPrice}</b><br>
  <b>Minimum 30% Down Payment:</b> <b>${dp30}</b><br>
  <b>Due Date:</b> <b>${due3Str}</b></p>
  <p>To ensure that your booking is secured and all necessary arrangements are completed on schedule, we encourage you to settle the down payment within the given period. Please note that failure to remit the required down payment within the 3-day period may result in the expiration of the offer and forfeiture of your booking slot.</p>
  <p>If payment has already been made, please disregard this message.</p>
  <p>To view our payment options and complete your down payment, please click the button below:</p>
  <p>${buttonHtml}</p>
  ${SHARED_EMAIL_COMPONENTS.popInstructions( (business && String(business).trim()) ? toTitleCase_(business) : toTitleCase_(clientNameSafe), campaign, invoiceSerial)}
  <p>Should you have any questions or need clarification regarding the payment terms, please feel free to contact us â€” weâ€™re happy to assist.</p>
  <p>Thank you for your prompt attention to this requirement and for your trust in our services.</p>
  ${SHARED_EMAIL_COMPONENTS.signature}
  `;
  return { subject, html: body };
}

function encodeInvoiceReceipt() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = safeGetUi_();
  try {
    const sheet = ss.getSheetByName(CONFIG.SHEET_NAMES.INVOICE_ENCODER);
    const dbSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DATABASE);

    const dataRange = ss.getRangeByName(CONFIG.NAMED_RANGES.INVOICE_DATA);
    if (!dataRange) throw new Error(`Named Range "${CONFIG.NAMED_RANGES.INVOICE_DATA}" not found.`);
    const values = dataRange.getValues();

    const IDX = {
      date: 0, tin: 1, fullName: 2, business: 3, address: 4, city: 5, zip: 6,
      campaign: 7, amount: 8, dpDue: 9, fpDue: 10, email: 11, serial: 12, timeSent: 13
    };

    const requiredIdx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12];
    for (const i of requiredIdx) {
      if (values[i][0] === '') throw new Error('Please fill all required fields (O12-O21, O23-O24). Note: Full Payment Due Date (O22) is optional.');
    }
    
    const entryDate = values[IDX.date][0];
    const tin = values[IDX.tin][0];
    const clientName = values[IDX.fullName][0];
    const business = values[IDX.business][0];
    const address = values[IDX.address][0];
    const city = values[IDX.city][0];
    const zip = values[IDX.zip][0];
    const campaign = values[IDX.campaign][0];
    const amountRaw = values[IDX.amount][0];
    const dpDueDate = values[IDX.dpDue][0];
    const fpDueDate = values[IDX.fpDue][0];
    const clientEmail = values[IDX.email][0];
    const serialNo = values[IDX.serial][0];
    const timeSent = new Date();
    const amountNum = (typeof amountRaw === 'number') ? amountRaw : parseFloat(String(amountRaw).replace(/[^\d.-]/g, '')) || 0;

    const pdfBlob = exportSheetRangeToPdf_(CONFIG.SHEET_NAMES.INVOICE_ENCODER, CONFIG.NAMED_RANGES.INVOICE_PDF, `Invoice-${serialNo}.pdf`);

    const { subject: dpSubject, html: dpHtml } = buildDownpaymentEmail_({
      fullName: clientName, business: business, campaign: campaign, meetingDate: entryDate,
      givenAmount: amountNum, invoiceSerial: serialNo,
    });

    MailApp.sendEmail({ to: clientEmail, subject: dpSubject, htmlBody: dpHtml, attachments: [pdfBlob] });

    // --- SMART DATA TRANSFER (robust, bottom-scan on A5:A, with collision guard) ---
    const MIN_ROW = 5;
    const aCol = dbSheet.getRange(MIN_ROW, 1, dbSheet.getMaxRows() - (MIN_ROW - 1), 1).getValues();

    let lastNonEmptyOffset = -1;
    for (let i = aCol.length - 1; i >= 0; i--) {
      if (aCol[i][0] !== "" && aCol[i][0] !== null) {
        lastNonEmptyOffset = i;
        break;
      }
    }

    let firstEmptyRow = (lastNonEmptyOffset === -1) ? MIN_ROW : (MIN_ROW + lastNonEmptyOffset + 1);

    const newRowData = [[
      serialNo, entryDate, campaign, clientName, tin, business, address,
      city, zip, clientEmail, timeSent, amountNum, dpDueDate, fpDueDate
    ]];

    const targetCell = dbSheet.getRange(firstEmptyRow, 1).getValue();
    if (targetCell !== "" && targetCell !== null) {
      firstEmptyRow++;
    }

    dbSheet.getRange(firstEmptyRow, 1, 1, 14).setValues(newRowData);
    // --- END OF NEW LOGIC ---

    const clearRange = ss.getRangeByName(CONFIG.NAMED_RANGES.INVOICE_CLEAR);
    if (clearRange) clearRange.clearContent();
    
    ss.toast('Invoice receipt processed and sent successfully!', 'Success', 5);
  } catch (e) {
    Logger.log(`Error in encodeInvoiceReceipt: ${e.message}`);
    if (ui) ui.alert('An Error Occurred', e.message, ui.ButtonSet.OK);
  }
}

// [REPLACE your existing encodeAcknowledgementReceipt function with this]
function encodeAcknowledgementReceipt() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = safeGetUi_();
  try {
    const sheet = ss.getSheetByName(CONFIG.SHEET_NAMES.AR_ENCODER);
    const dbSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.SALES_DB);
    // ... [Data reading and validation logic remains the same] ...
    const values = ss.getRangeByName(CONFIG.NAMED_RANGES.AR_DATA).getValues();
    const { arNumber, serialInvoiceNo, dateReceived, modeOfPayment, amountRaw, clientEmail, clientNameRaw } = extractArData_(values);
    
    // ... [PDF and Email logic remains the same] ...
    const pdfBlob = exportSheetRangeToPdf_(CONFIG.SHEET_NAMES.AR_ENCODER, CONFIG.NAMED_RANGES.AR_PDF, `AR-${arNumber}.pdf`);
    const pdfFile = getOrCreateFolder_('Acknowledgement Receipts').createFile(pdfBlob);
    // ... build and send email ...

    // --- YOUR NEW ROBUST DATA TRANSFER LOGIC ---
    const MIN_ROW = 5;
    const aCol = dbSheet.getRange(MIN_ROW, 1, dbSheet.getMaxRows() - (MIN_ROW - 1), 1).getValues();
    let lastNonEmptyOffset = -1;
    for (let i = aCol.length - 1; i >= 0; i--) {
      if (aCol[i][0] !== "" && aCol[i][0] !== null) {
        lastNonEmptyOffset = i;
        break;
      }
    }
    let firstEmptyRow = (lastNonEmptyOffset === -1) ? MIN_ROW : (MIN_ROW + lastNonEmptyOffset + 1);
    const newRowData = [[
        arNumber, serialInvoiceNo, dateOnly_(dateReceived), modeOfPayment,
        (typeof amountRaw === 'number' ? amountRaw : parseFloat(String(amountRaw).replace(/[^\d.-]/g, '')) || 0),
        '', '', '', pdfFile.getUrl()
    ]];
    const targetCell = dbSheet.getRange(firstEmptyRow, 1).getValue();
    if (targetCell !== "" && targetCell !== null) {
      firstEmptyRow++;
    }
    dbSheet.getRange(firstEmptyRow, 1, 1, 9).setValues(newRowData);
    // --- END OF NEW LOGIC ---
    
    // This part still needs to be refactored to a named range for best practice
    const AR_CLEAR_RANGES_TEMP = ['O12', 'O16:O18'];
    sheet.getRangeList(AR_CLEAR_RANGES_TEMP).clearContent();
    ss.toast('Receipt processed, saved to Drive, and sent!', 'Success', 5);
  } catch (e) {
    Logger.log(`Error in encodeAcknowledgementReceipt: ${e.message}`);
    if (ui) ui.alert('An Error Occurred', e.message, ui.ButtonSet.OK);
  }
}

// NOTE: You will also need to add the helper functions extractInvoiceData_ and extractArData_
// And update the email builders to use CONFIG.COMPANY_NAME as you identified.
/**
 * Sends conditional follow-up emails based on the proximity of the due date.
 */
function sendDailyFollowUps() {
  const ui = SpreadsheetApp.getUi();
  try {
    const dpResult = processFollowUpsBySerial_(false);
    const fpResult = processFullPaymentFollowUps_(false);
    const totalEmails = dpResult.emailsSent + fpResult.emailsSent;
    ui.alert('Follow-Ups Complete', `${totalEmails} follow-up emails have been sent.\n\nDown Payments: ${dpResult.emailsSent}\nFull Payments: ${fpResult.emailsSent}`, ui.ButtonSet.OK);
  } catch (e) {
    Logger.log(e);
    ui.alert('An Error Occurred', e.message, ui.ButtonSet.OK);
  }
}

function sendDailyFollowUpsForce() {
  const ui = safeGetUi_(); // may be null outside UI
  try {
    // Calls both DP and FP follow-ups, passing 'true' to force them
    const dpResult = processFollowUpsBySerial_(true);
    const fpResult = processFullPaymentFollowUps_(true);
    const totalEmails = dpResult.emailsSent + fpResult.emailsSent;

    const message = `${totalEmails} follow-up emails have been sent (todayâ€™s stamps were ignored).\n\nDown Payments: ${dpResult.emailsSent}\nFull Payments: ${fpResult.emailsSent}`;
    if (ui) ui.alert('FORCED Follow-Ups Complete', message, ui.ButtonSet.OK);
    Logger.log(`FORCED Follow-Ups Complete: ${message}`);
  } catch (e) {
    Logger.log(e);
    if (ui) ui.alert('An Error Occurred', e.message, ui.ButtonSet.OK);
  }
}


/**
 * Trigger-safe follow-ups (no UI). Use this in time-based triggers.
 * Reads from 'EntryDatabase' using the header row on ROW 4.
 */
function sendDailyFollowUpsTrigger() {
  try {
    const dpResult = processFollowUpsBySerial_(false);
    const fpResult = processFullPaymentFollowUps_(false);
    const totalEmails = dpResult.emailsSent + fpResult.emailsSent;
    Logger.log(`Daily Follow-Ups Trigger Complete. Total Sent: ${totalEmails} (DP: ${dpResult.emailsSent}, FP: ${fpResult.emailsSent}). Statuses Updated: ${fpResult.updatedStatuses}.`);
  } catch (e) {
    Logger.log("Trigger follow-ups error: " + e.message);
  }
}

/**
 * Shared core logic for follow-ups.
 * - Headers at ROW 4, data from ROW 5 down.
 * - Stamps "Last Follow-Up Sent" in Column T (T5:T) on the SAME ROW as the serial in Column A.
 * - If force=true, send even if stamped today (overwrites todayâ€™s stamp). If false, skip if stamped today.
 * Returns { emailsSent }.
 */
// [REPLACE your existing processFollowUpsBySerial_ function with this]
function processFollowUpsBySerial_(force = false) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DATABASE);
  if (!sheet) throw new Error(`Sheet '${CONFIG.SHEET_NAMES.DATABASE}' not found.`);

  const lastRow = sheet.getLastRow();
  if (lastRow < 5) return { emailsSent: 0 };
  const dataRange = sheet.getRange('A5:T' + lastRow);
  const values = dataRange.getValues();
  const today = dateOnly_(new Date());
  let emailsSent = 0;
  
  const H = { 
    serial: 0, campaign: 2, name: 3, business: 5, email: 9, 
    givenAmount: 11, dpDueDate: 12, percentage: 14, lastFollowUp: 19 
  };

  // --- FIX: Read from the 'sheet', not 'dataRange' ---
  const updatedTimestamps = sheet.getRange('T5:T' + lastRow).getValues();

  values.forEach((row, i) => {
    try {
      let pctRaw = row[H.percentage];
      let pct = (typeof pctRaw === 'number') ? pctRaw : parseFloat(String(pctRaw || "0").replace("%", "").trim());
      if (isNaN(pct)) pct = 0;
      if (pct > 1) pct = pct / 100;
      if (pct >= 0.30) return;

      const dpDueDate = row[H.dpDueDate];
      if (!(dpDueDate instanceof Date)) return;
      const dueOnly = dateOnly_(dpDueDate);
      if (dueOnly < today) return;

      const lastSent = row[H.lastFollowUp];
      if (!force && lastSent instanceof Date && isSameDay_(lastSent, new Date())) return;

      const email = String(row[H.email] || '').split(/[;,]/)[0].trim();
      if (!email) return;

      const { subject, html } = buildDownpaymentEmail_({
        fullName: row[H.name],
        business: row[H.business],
        campaign: row[H.campaign],
        meetingDate: new Date(), // Using today as Entry Date is not in the A5:T range.
        givenAmount: row[H.givenAmount],
        invoiceSerial: row[H.serial],
      });
      MailApp.sendEmail(email, subject, "", { htmlBody: html });
      emailsSent++;
      updatedTimestamps[i][0] = new Date();
    } catch (e) {
      Logger.log(`Error in DP Follow-up for row ${i + 5} (Serial: ${row[H.serial]}): ${e.message}`);
    }
  });

  if (emailsSent > 0) {
    sheet.getRange('T5:T' + lastRow).setValues(updatedTimestamps);
  }
  return { emailsSent };
}


// [REPLACE your existing processFullPaymentFollowUps_ function with this]
function processFullPaymentFollowUps_(force = false) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DATABASE);
  if (!sheet) throw new Error(`Sheet '${CONFIG.SHEET_NAMES.DATABASE}' not found.`);
  
  const lastRow = sheet.getLastRow();
  if (lastRow < 5) return { emailsSent: 0, updatedStatuses: 0 };
  const dataRange = sheet.getRange('A5:T' + lastRow);
  const values = dataRange.getValues();
  const today = dateOnly_(new Date());
  let emailsSent = 0;
  let updatedStatuses = 0;
  
  const H = {
    serial: 0, campaign: 2, name: 3, business: 5, email: 9,
    givenAmount: 11, fpDueDate: 13, percentage: 14, repayment: 15,
    receivables: 17, status: 18, lastFollowUp: 19
  };

  const updatedStatusesArr = sheet.getRange('S5:S' + lastRow).getValues();
  const updatedTimestamps = sheet.getRange('T5:T' + lastRow).getValues();

  values.forEach((row, i) => {
    try {
      const status = String(row[H.status] || '').toUpperCase().trim();
      const receivables = (typeof row[H.receivables] === 'number') ? row[H.receivables] : 0;
      const fpDueDate = row[H.fpDueDate];

      if (status === 'PAID' || status === 'CANCELLED' || status === 'FORFEITED' || !(fpDueDate instanceof Date) || receivables <= 0) {
        return;
      }
      
      let pctRaw = row[H.percentage];
      let pct = (typeof pctRaw === 'number') ? pctRaw : parseFloat(String(pctRaw || "0").replace("%","").trim());
      if (isNaN(pct)) pct = 0;
      if (pct > 1) pct /= 100;
      if (pct < 0.30) return;
      
      // --- THIS BLOCK IS NOW REMOVED for the regular trigger ---
      // const lastSent = row[H.lastFollowUp];
      // if (!force && lastSent instanceof Date && isSameDay_(lastSent, new Date())) {
      //   return;
      // }

      const dueOnly = dateOnly_(fpDueDate);
      const daysOverdue = Math.ceil((today.getTime() - dueOnly.getTime()) / (1000 * 60 * 60 * 24));
      
      const emailData = {
        clientName: toTitleCase_(row[H.name] || row[H.business] || firstNameFromEmail_(row[H.email])),
        serialNo: row[H.serial],
        campaign: row[H.campaign] || 'engagement',
        // ... (rest of emailData)
      };
      
      let email;

      // --- Logic to build the email remains the same ---
      if (daysOverdue === -1) { email = buildFpReminderEmail_(emailData); }
      // ... (else if blocks for other emails) ...

      if (email) {
        const clientEmail = String(row[H.email] || '').split(/[;,]/)[0].trim();
        if (clientEmail) {
          MailApp.sendEmail({ to: clientEmail, subject: email.subject, htmlBody: email.html });
          updatedTimestamps[i][0] = new Date();
          emailsSent++;
        }
      }

    } catch (e) {
      Logger.log(`Error processing row ${i + 5} (Serial: ${row[H.serial]}): ${e.message}`);
    }
  });

  if (emailsSent > 0) {
    sheet.getRange('T5:T' + lastRow).setValues(updatedTimestamps);
  }
  if (updatedStatuses > 0) {
    sheet.getRange('S5:S' + lastRow).setValues(updatedStatusesArr);
  }

  return { emailsSent, updatedStatuses };
}

// --- FULL PAYMENT EMAIL BUILDER HELPERS ---

function buildFpReminderEmail_({ clientName, serialNo, campaign, receivablesStr, dueDateStr }) {
  const subject = `Friendly Reminder: [Billing Invoice #${serialNo}] â€“ Due Tomorrow`;
  const html = `
    <p>Hi ${clientName},</p>
    <p>I hope youâ€™re doing well. This is a friendly reminder regarding Invoice #${serialNo} for your <b>${campaign}</b> engagement with ${COMPANY_NAME}. Our records indicate a remaining balance of <b>${receivablesStr}</b>, which is due tomorrow, <b>${dueDateStr}</b>.</p>
    <p>To ensure a smooth process and avoid any late fees or service interruptions, we encourage arranging settlement within the due date.</p>
    ${SHARED_EMAIL_COMPONENTS.paymentMadeIgnore}
    ${SHARED_EMAIL_COMPONENTS.paymentButton}
    ${SHARED_EMAIL_COMPONENTS.popInstructions(clientName, campaign, serialNo)}
    <p>If you have any questions or require assistance with the payment process, please donâ€™t hesitate to reach out â€” weâ€™re happy to assist.</p>
    <p>Thank you for your prompt attention to this matter and for your continued partnership.</p>
    ${SHARED_EMAIL_COMPONENTS.signature}`;
  return { subject, html };
}

function buildFpDueTodayEmail_({ clientName, serialNo, campaign, receivablesStr }) {
  const subject = `Gentle Reminder: [Billing Invoice #${serialNo}] Due Today (until 5:00 PM)`;
  const html = `
    <p>Hi ${clientName},</p>
    <p>Hope youâ€™re doing well. Just a gentle checkâ€‘in on Invoice #${serialNo} for your <b>${campaign}</b> with ${COMPANY_NAME}. Our records show a remaining balance of <b>${receivablesStr}</b> thatâ€™s due today. When convenient, kindly settle on or before <b>5:00 PM</b>.</p>
    ${SHARED_EMAIL_COMPONENTS.paymentMadeIgnore}
    ${SHARED_EMAIL_COMPONENTS.paymentButton}
    ${SHARED_EMAIL_COMPONENTS.popInstructions(clientName, campaign, serialNo)}
    <p>If you have any questions or need clarification, please donâ€™t hesitate to reach out to usâ€”weâ€™re happy to assist.</p>
    <p>Thank you for your continued partnership and for taking a moment to review this.</p>
    ${SHARED_EMAIL_COMPONENTS.signature}`;
  return { subject, html };
}

function buildFpOverdueEmail_({ clientName, serialNo, campaign, receivablesStr, dueDateStr, daysPastDue }) {
  const subject = `Gentle Reminder: [Billing Invoice #${serialNo}] â€“ Payment ${daysPastDue} Day${daysPastDue > 1 ? 's' : ''} Past Due`;
  const html = `
    <p>Hi ${clientName},</p>
    <p>Hope youâ€™re doing well. This is a gentle follow-up regarding Invoice #${serialNo} for your <b>${campaign}</b> with ${COMPANY_NAME}. Our records show an outstanding balance of <b>${receivablesStr}</b>, originally due on <b>${dueDateStr}</b>, which is now <b>${daysPastDue} day${daysPastDue > 1 ? 's' : ''} past due</b>.</p>
    <p>We completely understand that schedules can get busy and payment dates may sometimes be overlooked. To help avoid any late fees or possible service interruptions, we would greatly appreciate it if you could arrange settlement at your earliest convenience.</p>
    ${SHARED_EMAIL_COMPONENTS.paymentMadeIgnore}
    ${SHARED_EMAIL_COMPONENTS.paymentButton}
    ${SHARED_EMAIL_COMPONENTS.popInstructions(clientName, campaign, serialNo)}
    <p>If you have any questions or need assistance with the payment process, please donâ€™t hesitate to reach out to usâ€”weâ€™re happy to assist.</p>
    <p>Thank you for your attention to this matter and for your continued partnership.</p>
    ${SHARED_EMAIL_COMPONENTS.signature}`;
  return { subject, html };
}

function buildFpUrgentEmail_({ clientName, serialNo, campaign, dueDateStr, daysPastDue, penaltyAmountStr, newTotalStr }) {
  const subject = `Urgent Reminder: [Billing Invoice #${serialNo}] â€“ Past Due with Penalty Applied`;
  const html = `
    <p>Hi ${clientName},</p>
    <p>I hope this message finds you well.</p>
    <p>This is an urgent follow-up regarding Invoice #${serialNo} for your <b>${campaign}</b> engagement with ${COMPANY_NAME}. Our records show that the payment is now <b>${daysPastDue} days past due</b> from the agreed due date of <b>${dueDateStr}</b>.</p>
    <p>Due to ${daysPastDue} days overdue, the total late payment penalty has increased to thirty percent (30%) of the total contract price in accordance with our payment agreement. The outstanding balance should be settled immediately to avoid further charges and potential service interruption.</p>
    <p><b>Original Contract Price:</b> ${penaltyAmountStr}<br>
    <b>Total of 30% Late Payment Penalty:</b> ${penaltyAmountStr}<br>
    <b>Updated Amount Due:</b> ${newTotalStr}</p>
    ${SHARED_EMAIL_COMPONENTS.paymentMadeIgnore}
    ${SHARED_EMAIL_COMPONENTS.paymentButton}
    ${SHARED_EMAIL_COMPONENTS.popInstructions(clientName, campaign, serialNo)}
    <p>Should you need clarification on the updated amount or assistance in processing the payment, please do not hesitate to reach out â€” weâ€™re here to assist you.</p>
    <p>Thank you for your immediate attention to this matter.</p>
    ${SHARED_EMAIL_COMPONENTS.signature}`;
  return { subject, html };
}

function buildFpForfeitureEmail_({ clientName, serialNo, campaign, dueDateStr, receivablesStr, contractPriceStr, todayStr }) {
  const subject = `Final Notice: [Billing Invoice #${serialNo}] â€“ Forfeiture of Contract & Payment`;
  const html = `
    <p>Hi ${clientName},</p>
    <p>I hope this message finds you well.</p>
    <p>This is a formal and final notice regarding Invoice #${serialNo} for your <b>${campaign}</b> engagement with ${COMPANY_NAME}. Our records show that no payment has been made for the past seven (7) days from the agreed due date of <b>${dueDateStr}</b>.</p>
    <p>In accordance with our official Payment Terms & Conditions, the non-settlement of your outstanding balance within the prescribed period has resulted in the automatic forfeiture of your payment and all services under the contract effective today. This forfeiture is final, non-reversible, and without refund.</p>
    <p><b>Original Contract Price:</b> ${contractPriceStr}<br>
    <b>Outstanding Balance:</b> ${receivablesStr}<br>
    <b>Status:</b> Forfeited as of ${todayStr}</p>
    <p>All services covered by this contract are hereby terminated, and no further reinstatement or grace period will be granted.</p>
    <p>If you believe this notice has reached you in error, kindly contact us immediately at ${FINANCE_EMAIL}. Otherwise, please be advised that this matter is now considered closed.</p>
    <p>We thank you for your prior engagement with ${COMPANY_NAME}.</p>
    ${SHARED_EMAIL_COMPONENTS.signature}`;
  return { subject, html };
}

// Helper object for shared email text to avoid repetition
const SHARED_EMAIL_COMPONENTS = {
  paymentButton: `<p><a href="${CONFIG.PAYMENT_LINK}" style="background-color:#007bff; color:#fff; padding:10px 16px; text-decoration:none; border-radius:6px; display:inline-block;">View Payment Options</a></p>`,
  paymentMadeIgnore: `<p>If payment has already been made, please disregard this message.</p>`,
  popInstructions: (clientName, campaign, serialNo) => `
    <hr>
    <p><b>Proof of Payment (PoP) Instructions</b><br>
    Email your proof of payment to <a href="mailto:${CONFIG.FINANCE_EMAIL}">${CONFIG.FINANCE_EMAIL}</a>.<br>
    <em>Use this subject line format:</em><br>
    <code><b>${clientName} â€“ ${campaign || 'Project'}</b></code><br>
    Attach the deposit slip or transfer confirmation and include your Invoice <b>#${serialNo}</b> in the email body.</p>`,
  signature: `
    <p>Warm regards,<br>
    <b>${CONFIG.COLLECTIONS_OFFICER_NAME}</b><br>
    ${CONFIG.COLLECTIONS_OFFICER_TITLE}<br>
    ${CONFIG.COMPANY_NAME}<br>
    ðŸ“§ <a href="mailto:${CONFIG.FINANCE_EMAIL}">${CONFIG.FINANCE_EMAIL}</a> | ðŸ“± ${CONFIG.FINANCE_PHONE}</p>`
};

// --- PDF UTILS ---

/**
 * Creates a PDF from a range by copying to a temporary spreadsheet.
 * (Kept for optional use; not used in main flow)
 */
function makePdfFromRange_(sheetName, rangeA1, pdfName) {
  const sourceSs   = SpreadsheetApp.getActiveSpreadsheet();
  const sourceSheet= sourceSs.getSheetByName(sheetName);

  // Temp spreadsheet
  const tempSs = SpreadsheetApp.create(`Temp - ${pdfName}`);
  const tempId = tempSs.getId();

  // Copy source sheet to temp
  sourceSheet.copyTo(tempSs);
  // Delete default Sheet1
  const s1 = tempSs.getSheetByName('Sheet1');
  if (s1) { s1.activate(); tempSs.deleteActiveSheet(); }

  const copiedSheet = tempSs.getSheets()[0];
  const range = copiedSheet.getRange(rangeA1);
  const startRow = range.getRow();
  const startCol = range.getColumn();
  const numRows  = range.getNumRows();
  const numCols  = range.getNumColumns();

  cropSheetToRange_(copiedSheet, startRow, startCol, numRows, numCols);

  const pdfBlob = tempSs.getAs('application/pdf').setName(pdfName);
  DriveApp.getFileById(tempId).setTrashed(true);
  return pdfBlob;
}

/**
 * Deletes all rows and columns outside of a specified range.
 */
function cropSheetToRange_(sheet, startRow, startCol, numRows, numCols) {
  const maxRows = sheet.getMaxRows();
  const maxCols = sheet.getMaxColumns();

  if (maxRows > startRow + numRows - 1) {
    sheet.deleteRows(startRow + numRows, maxRows - (startRow + numRows - 1));
  }
  if (startRow > 1) {
    sheet.deleteRows(1, startRow - 1);
  }
  if (maxCols > startCol + numCols - 1) {
    sheet.deleteColumns(startCol + numCols, maxCols - (startCol + numCols - 1));
  }
  if (startCol > 1) {
    sheet.deleteColumns(1, startCol - 1);
  }
}

/**
 * Exports a specific range to a PDF blob via export URL.
 */
function exportSheetRangeToPdf_(sheetName, rangeA1, filename) {
  const ss     = SpreadsheetApp.getActiveSpreadsheet();
  const sheet  = ss.getSheetByName(sheetName);
  const sheetId= sheet.getSheetId();

  const url = `https://docs.google.com/spreadsheets/d/${ss.getId()}/export?` +
    `format=pdf&gid=${sheetId}&range=${encodeURIComponent(rangeA1)}&size=letter&portrait=true&fitw=true` +
    `&gridlines=false&printnotes=false`;

  const response = UrlFetchApp.fetch(url, {
    headers: { 'Authorization': 'Bearer ' + ScriptApp.getOAuthToken() }
  });

  return response.getBlob().setName(filename);
}

/**
 * Finds a folder by name or creates it if it doesn't exist.
 */
function getOrCreateFolder_(folderName) {
  const folders = DriveApp.getFoldersByName(folderName);
  if (folders.hasNext()) return folders.next();
  return DriveApp.createFolder(folderName);
}
